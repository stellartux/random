<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Transposer</title>
  <style>
    :root {
      color-scheme: dark light;
      font-family: sans-serif;
    }

    body {
      display: flex;
      flex-direction: column;
      margin: auto;
      width: fit-content;
      font-size: large;
    }

    h1 {
      align-self: center;
    }

    select {
      font-size: large;
    }

    #input-chords {
      margin: 2ch 0;
      font-size: larger;
      padding: 1ch;
    }

    #help-toggle {
      position: absolute;
      top: 2ch;
      right: 2ch;
      font-size: x-large;
      width: 3ch;
      height: 3ch;
    }

    table {
      width: 100%;
    }

    tr td {
      font-size: xxx-large;
      width: 50%;
      line-height: 1.3;
    }

    .input-chord {
      text-align: right;
    }

    .input-chord::after {
      content: '→';
      position: relative;
      top: -0.2ch;
    }
  </style>
</head>

<body>
  <h1>Transpose</h1>
  <div>
    <label for="input-key">from the key of </label>
    <select id="input-key">
      <option value="0">C</option>
      <option value="1">C♯/D♭</option>
      <option value="2">D</option>
      <option value="3">D♯/E♭</option>
      <option value="4">E</option>
      <option value="5">F</option>
      <option value="6">F♯/G♭</option>
      <option value="7">G</option>
      <option value="8">G♯/A♭</option>
      <option value="9">A</option>
      <option value="10">A♯/B♭</option>
      <option value="11">B</option>
    </select>
    <label for="output-key">to the key of </label>
    <select id="output-key">
      <option value="0">C</option>
      <option value="1">C♯/D♭</option>
      <option value="2">D</option>
      <option value="3">D♯/E♭</option>
      <option value="4">E</option>
      <option value="5">F</option>
      <option value="6">F♯/G♭</option>
      <option value="7">G</option>
      <option value="8">G♯/A♭</option>
      <option value="9">A</option>
      <option value="10">A♯/B♭</option>
      <option value="11">B</option>
    </select>
    <select id="accidentals">
      <option value="auto"></option>
      <option value="flat">using flats</option>
      <option value="sharp">using sharps</option>
    </select>

  </div>
  <input id="input-chords" type="text" value="C G Am F" placeholder="Try 'C G Am7 Fmaj7' or 'I V vi7 IVmaj7'" />
  <output>
    <table>
      <tbody id="output-chords"></tbody>
    </table>
  </output>
  <template id="template-output">
    <tr>
      <td class="input-chord"></td>
      <td class="output-chord"></td>
    </tr>
  </template>
  <script>
    //@ts-check
    'strict mode'

    const sharps = Object.freeze(['C', 'C♯', 'D', 'D♯', 'E', 'F', 'F♯', 'G', 'G♯', 'A', 'A♯', 'B'])
    const flats = Object.freeze(['C', 'D♭', 'D', 'E♭', 'E', 'F', 'G♭', 'G', 'A♭', 'A', 'B♭', 'B'])

    /** @returns {any} */
    const $$ = (/** @type {string} */ id) => document.getElementById(id)

    const /** @type {HTMLSelectElement} */ inputKey = $$('input-key')
    const /** @type {HTMLSelectElement} */ outputKey = $$('output-key')
    const /** @type {HTMLSelectElement} */ selectAccidentals = $$('accidentals')
    const /** @type {HTMLInputElement} */inputChords = $$('input-chords')
    const /** @type {HTMLTableElement} */ outputChords = $$('output-chords')
    const /** @type {HTMLTemplateElement} */ template = $$('template-output')

    //@ts-ignore
    const url = new URL(window.location)

    inputChords.textContent = (url.searchParams.get('c') || '').replace(/_/g, ' ')
    inputKey.value = url.searchParams.get('f') || '0'
    outputKey.value = url.searchParams.get('t') || '0'
    if (url.searchParams.has('p')) {
      const /** @type {HTMLOptionElement?} */ el =
        selectAccidentals.querySelector(`option[value^="${url.searchParams.get('p')}"]`)
      if (el) { el.selected = true }
    }

    inputKey.addEventListener('change', updateChordList)
    outputKey.addEventListener('change', updateChordList)
    inputChords.addEventListener('input', updateChordList)
    selectAccidentals.addEventListener('change', updateChordList)
    updateChordList()

    function parseChord(/** @type {string} */ chordName) {
      return (
        chordName.match(/^(?<chord>(?<accidentals>[#b♭♯♮]*)(?<root>iv|i{1,3}|vi{0,2})(?<quality>.*)(?<roman>))/i)
        || chordName.match(/^(?<chord>(?<root>[a-g])(?<accidentals>[#b♭♯♮]*)(?<quality>.*))/i)
      )?.groups
    }

    function transpose(chord, /** @type {number} */ semitones, flat = false) {
      if (typeof chord === 'string') {
        chord = parseChord(chord)
        if (!chord) throw new Error('Could not parse chord')
      }
      //@ts-ignore
      let { root, accidentals, quality } = chord
      if (/^[iv]/.test(root) && !/^([-+o]|dim)/.test(quality)) {
        quality = 'm' + quality
      }
      const accidentalOffset = accidentals.split('').reduce((a, c) => a + ({ '#': 1, '♯': 1, '♭': -1, 'b': -1 }[c] || 0), 0)
      return (flat ? flats : sharps)[((
        semitones +
        {
          C: 0, D: 2, E: 4, F: 5, G: 7, A: 9, B: 11,
          I: 0, II: 2, III: 4, IV: 5, V: 7, VI: 9, VII: 11,
        }[root.toUpperCase()] + accidentalOffset
      ) % 12 + 12) % 12] + quality
    }

    function updateChordList() {
      while (outputChords.lastElementChild) {
        outputChords.removeChild(outputChords.lastElementChild)
      }
      const offset = (12 + Number(outputKey.value) - Number(inputKey.value)) % 12
      const romanOffset = Number(outputKey.value)
      let preferFlats = Boolean([1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1][outputKey.value])
      if (selectAccidentals.value === 'flat') {
        preferFlats = true
      } else if (selectAccidentals.value === 'sharp') {
        preferFlats = false
      }
      for (const chordName of inputChords.value.trim().split(/\s+/g)) {
        const node = template.content.cloneNode(true)
        const chord = parseChord(chordName)
        //@ts-ignore
        node.querySelector('.input-chord').textContent = chordName
        //@ts-ignore
        node.querySelector('.output-chord').textContent = transpose(chord, 'roman' in chord ? romanOffset : offset, preferFlats)
        outputChords.append(node)
      }
      url.searchParams.set('c', inputChords.value.trim().replace(/\s+/g, '_'))
      url.searchParams.set('f', inputKey.value)
      url.searchParams.set('t', inputKey.value)
      if (selectAccidentals.value !== 'auto') {
        url.searchParams.set('p', selectAccidentals.value[0])
      } else {
        url.searchParams.delete('p')
      }
      window.history.replaceState({}, '', url)
    }
  </script>
</body>

</html>
