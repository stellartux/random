export class Vector extends Array{static operation(t,r,e){if("number"==typeof r&&e.length)return new Vector(...e.map(e=>t(r,e)));if("number"==typeof e&&r.length)return new Vector(...r.map(r=>t(r,e)));if(r.length===e.length)return new Vector(...r.map((r,o)=>t(r,e[o])));if("number"==typeof r&&"number"==typeof e)return t(r,e);throw new Error(`Could not apply ${t} to ${r}, ${e}`)}static add(t,r){return Vector.operation((t,r)=>t+r,t,r)}static sub(t,r){return Vector.operation((t,r)=>t-r,t,r)}static mul(t,r){return Vector.operation((t,r)=>t*r,t,r)}static div(t,r){return Vector.operation((t,r)=>t/r,t,r)}static normalize(t){return Vector.div(t,t.magnitude)}static equal(t,r){return Vector.operation((t,r)=>t===r,t,r)}static dot(t,r){return Vector.mul(t,r).reduce((t,r)=>t+r,0)}static cross(t,r){if(3!==t.length||3!==r.length)throw new Error("Can only calculate cross product of 3D vectors");return new Vector([t[1]*r[2]-t[2]*r[1],t[0]*r[2]-t[2]*t[0],t[0]*r[1]-t[1]*t[0]])}static rotate2D([t,r],e){const o=Math.cos(e),n=Math.sin(e);return new Vector([t*o-r*n,t*n+r*o])}copy(t){return t.forEach((t,r)=>{this[r]=t}),this}add(t){return this.copy(Vector.add(this,t)),this}sub(t){return this.copy(Vector.sub(this,t)),this}mul(t){return this.copy(Vector.mul(this,t)),this}div(t){return this.copy(Vector.div(this,t)),this}get magnitude(){return Math.hypot(...this)}normalize(){const t=this.magnitude;return this.forEach((r,e)=>{this[e]=r/t}),this}cross(t){return this.copy(Vector.cross(this,t)),this}rotate2D(t){const[r,e]=this,o=Math.cos(t),n=Math.sin(t);return this[0]=r*o-e*n,this[1]=r*n+e*o,this.normalize()}}
